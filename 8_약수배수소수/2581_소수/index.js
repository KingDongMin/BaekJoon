const fs = require('fs');
const input = fs.readFileSync('example_input.txt').toString().trim().split('\n');


 /**
  * [ 2581 - 소수 ]
  * 
  * 1. 입력값은 M과 N이 있다.
  * 2. M부터 N까지의 자연수에서 소수를 구한다.
  * 3. 모든 소수의 합과 소수들 중 최소값을 출력한다.
  * 4. 단, 소수가 없다면 -1을 출력한다.
  */

 /**
  * [ 해결 방안 ]
  * M이상 N이하의 각 자연수 X를 for문으로 조회한다.
  * X의 소수를 구하기 위해 1부터 X까지의 각 자연수로 x를 나누어 약수를 구한다.
  * X의 약수가 2개인 경우 소수로 판별하고 배열A에 추가한다.
  * 배열A의 길이가 0인 경우 -1을 출력하고
  * 아니라면 reduce와 첫번째 요소로 총합과 최소값을 출력한다.
  */

 /**
  * [ 풀이 과정 ]
  * 1. 입력값을 받아와 M과 N을 초기화한다.
  * 2. M이상 N이하의 자연수 구한다.
  * 3. 범위 내의 각 자연수가 소수인지 판별한다.
  * 4. 소수인 경우 배열에 추가한다.
  * 5. 소수들의 합을 구한다.
  * 6. 최소 값을 가진 소수 출력한다.
  * 7. 소수가 없는 경우 -1을 출력한다.
  */

 const M = Number(input[0]);
 const N = Number(input[1]);

 const arr = []; // 소수가 담길 배열

 for(let i = M ; i <= N ; i++){ // M부터 N까지 각 자연수
    
    let count = 0; // 약수의 개수

    for(let j = 1 ; j <= i ; j++){

        if(count > 2) break; // 약수가 2개를 초과하면 반복 중단
        
        if(i%j == 0){
            count++; // 약수일 경우 카운트 증가
        }
    }

    count == 2 && arr.push(i); // 해당 자연수의 약수가 2개라면 소수 -> 배열에 추가
}
if(arr.length == 0){ // 소수가 없다면
    console.log(-1)
}else{
    const sum = arr.reduce((sum,ele)=>sum+ele) // 소수들의 총합
    console.log(sum)
    console.log(arr[0]) // 소수들의 최소값
}

/** 
 * [ 리뷰 ]
 * - 기존의 방식은 자연수의 크기가 늘어날 수록 처리 속도가 느려진다.
 * - 제곱근과 에라토스테네스의 체를 이용하여 불필요한 소수 판별 연산을 줄일 수 있다.
 * 
*/

/** 
 * #1 제곱근을 이용한 소수 판별
 * - 제곱근을 통해 약수의 개수를 유추할 수 있다.
 * - 해당 자연수의 제곱근이 정수라면 제곱근이하 약수 * 2 + 1 = 총 약수 개수
 * - 제곱근이 실수라면 제곱근은 정수 약수가 아니므로 -1
 * - 예) 16의 약수 [1,2,4,8,16] -> 제곱근 4미만의 약수 2개 -> 2 * 2 + 1 = 5개
 * - 예) 
 */

const number = 28

for(let i = 2 ; i <= Math.ceil(Math.sqrt(number)); i++){
    if(number % i == 0 ){
        console.log(i)
    }
}